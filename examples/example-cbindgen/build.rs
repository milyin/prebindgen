//! Build script for generating C bindings using prebindgen and cbindgen.
//!
//! This example demonstrates how to use prebindgen in a language-specific binding crate
//! to generate C headers from a common FFI library.

use std::path::PathBuf;

use itertools::Itertools;

fn main() {
    // prebindgen part: create rust file with extern "C" functions
    let bindings_file = generate_ffi_bindings();
    // cbindgen part: create C headers from this rust file
    generate_c_headers(&bindings_file);
}

/// Generate rust FFI bindings file proxying "example-ffi" linbrary
///
/// This function takes items in "example-ffi" marked with "#[prebindgen]" macro
/// and wraps them to extern "C" functions for further making C headers
fn generate_ffi_bindings() -> PathBuf {
    // Create data source: the object which reads data generated by #[prebindgen] macro
    let source = prebindgen::Source::new(example_ffi::PREBINDGEN_OUT_DIR);

    // Create feature filter
    let feature_filter = prebindgen::filter_map::FeatureFilter::builder()
        .disable_feature("unstable") // Disable unstable features
        .disable_feature("internal") // Disable internal features
        .enable_feature("experimental") // Enable experimental features for cfg demo
        .enable_feature("advanced") // Enable advanced features for cfg demo
        .disable_feature("disabled_feature") // Disable this feature to demonstrate cfg preservation
        .enable_feature("skip_demo") // Enable skip_demo feature for cfg demo
        .build();

    // Create filter for stripping derives
    let strip_derives = prebindgen::map::StripDerives::builder()
        .strip_derive("Default") // Strip Default derive from structs
        .build();

    let strip_macros = prebindgen::map::StripMacros::builder()
        .strip_macro("default")
        .build();

    // Create replacer for types without full paths
    let type_replacer = prebindgen::map::replace_types::Builder::new()
        .replace_type("Option", "std::option::Option")
        .replace_type("mem::MaybeUninit", "std::mem::MaybeUninit")
        .build();

    // Create converter from the source items to FFI proxy items. It needs original crate name
    // for generating proxy functions. This name can be taken from source or passed explicitly if
    // source crate is imported with renaming
    let converter = prebindgen::batching::FfiConverter::builder(source.crate_name())
        .strip_transparent_wrapper("std::option::Option") // Strip Option wrapper
        .strip_transparent_wrapper("std::mem::MaybeUninit") // Strip MaybeUninit wrapper
        .prefixed_exported_type("foo::Foo")
        .prefixed_exported_type("foo::InsideFoo")
        .build();

    // Do the conversion: take stream of syn::Item from source, process them with necessary
    // filters and dtore to destination rust file
    let bindings_file = source
        .items_all()
        .map(strip_derives.into_closure())
        .map(strip_macros.into_closure())
        .map(type_replacer.into_closure())
        .filter_map(feature_filter.into_closure())
        .batching(converter.into_closure())
        .collect::<prebindgen::collect::Destination>()
        .write("example_ffi.rs");

    println!(
        "cargo:warning=Generated bindings at: {}",
        bindings_file.display()
    );

    bindings_file
}

/// Generate C header files using cbindgen from the prebindgen-generated Rust code.
///
/// This function demonstrates how to integrate prebindgen with cbindgen:
/// 1. prebindgen generates extern "C" wrapper functions in Rust
/// 2. cbindgen processes those functions to create C header files
/// 3. The result is a clean separation between common FFI logic and C-specific bindings
fn generate_c_headers(cleaned_bindings_file: &PathBuf) {
    let crate_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let config = cbindgen::Config::from_root_or_default(&crate_dir);

    let header_path = PathBuf::from(&out_dir).join("example_ffi.h");

    // Use cbindgen to generate C headers from the prebindgen-generated Rust file
    // The key insight: we pass the generated Rust file as a source to cbindgen
    // This allows cbindgen to see the extern "C" functions without them being
    // directly defined in this crate (which would require cdylib/staticlib)
    match cbindgen::Builder::new()
        .with_config(config)
        .with_crate(&crate_dir)
        .with_src(cleaned_bindings_file) // Use the prebindgen-generated file as source
        .generate()
    {
        Ok(bindings) => {
            bindings.write_to_file(&header_path);
            println!(
                "cargo:warning=Generated C headers at: {}",
                header_path.display()
            );
        }
        Err(e) => {
            println!("cargo:warning=Failed to generate C headers: {e:?}");
        }
    }
}
